#!/bin/bash

###########################################################################################################
# Header
#
AXIOM_PATH="$HOME/.axiom"
source "$AXIOM_PATH/interact/includes/vars.sh"
source "$AXIOM_PATH/interact/includes/functions.sh"
source "$AXIOM_PATH/interact/includes/system-notification.sh"
begin=$(date +%s)
start="$(pwd)"
BASEOS="$(uname)"
case $BASEOS in
'Darwin')
    PATH="$(brew --prefix coreutils)/libexec/gnubin:$PATH"
    ;;
*) ;;
esac

###########################################################################################################
# Functions
#
function formatSeconds (){
        declare format='%02dh:%02dm:%02ds'         # time format hh:mm:sshconfig
        declare timepassed=$1
        declare seconds minutes hours

        ((seconds=timepassed%60))
        ((minutes=timepassed/60))
        ((hours=minutes/60))
        ((minutes=minutes%60))
        printf "$format" $hours $minutes $seconds
}

###########################################################################################################
# List path of all axiom modules and their commands axiom-scan --list
#
function list_modules() {
	echo -e "${Green}Available Modules:${Color_Off}"
	(echo "MODULE,COMMAND"; find "$AXIOM_PATH/modules" -name '*.json' -exec echo -n {}\` \; -exec jq -r '.[0].command' {} \; | sort -t/ | sed 's/\/$HOME\/.axiom\/modules\///g' | sed 's/\.json//g' ) | column -t -s\` | perl -pe '$_ = "\033[0;37m$_\033[0;34m" if($. % 2)'
}

###########################################################################################################
# Parsing the modules with jq. TODO: Ignore comments when parsing. This will allow us to have comments in the modules itself. 
# Allowing us to provide extra details/examples of the modules
#
function parse_module() {
	module="$1"
	ext="$2"

	if [[ -f "$AXIOM_PATH/modules/$module.json" ]]; then
		if [[ "$ext" != "" ]]; then
			cat "$AXIOM_PATH/modules/$module.json" | jq -r ".[] | select(.ext==\"$ext\")"
		else
			cat "$AXIOM_PATH/modules/$module.json" | jq -r ".[0]"
		fi
	else
		echo -e "${BRed}Module '$module' does not exist...${Color_Off}"
		list_modules
	fi
}

###########################################################################################################
# Help Menu:
# add --rm-duplicates ( remove duplicates from target list, sort -u equivalent  )
# add option to supply different SSH key 
# 
function help(){
        echo -e "${BWhite}Usage of axiom-scan${Color_Off}"
        echo -e "Example Usage: ${Blue}axiom-scan ips.txt -m nmap -T4 --top-ports 2000 -oX output.xml${Color_Off}"
        echo -e "  --list (optional)"
        echo -e "    List available modules"
        echo -e "  <input> required string"
        echo -e "    Input file, supplied as a positional first argument"
        echo -e "  -m required string"
        echo -e "    Module to use to scan (e.g masscan, nmap, gowitness, ffuf)"
        echo -e "  --dont-shuffle (optional)"
        echo -e "    Do not randomize input file before uploading (default is to randomize)"
        echo -e "  --dont-split (optional)"
        echo -e "    Do not split input file, upload entire input file to every instance (default is to split the target list)"
        echo -e "  -wL /path/to/local"
        echo -e "    Local wordlist to upload and use with axiom-scan (must be a path to a local wordlist)"
        echo -e "  -wD/--distribute-wordlist (optional, depends on -wL)"
        echo -e "    When using -wL, split and upload local wordlist (default is to not split the wordlist)"
        echo -e "  -w /path/to/wordlist/on/instance"
        echo -e "    Wordlist to use for axiom-scan (must be a path to a remote wordlist)"
        echo -e "  -o string"
        echo -e "    Output as default, whatever the first extension in the module is"
        echo -e "  -oX string"
        echo -e "    Output in XML/HTML, supported in (nmap & masscan)"
        echo -e "  -oG string"
        echo -e "    Output to greppable output (will merge and sort unique)"
        echo -e "  -oD/-oA string"
        echo -e "    Output results to directory"
        echo -e "  -F string (optional)"
        echo -e "    Custom SSH configuration file to launch fleet from"
        echo -e "  --fleet string (optional)"
        echo -e "    Fleet to use, will use axiom-select by default."
        echo -e "  --spinup int (optional)"
        echo -e "    How many instances to spin up"
        echo -e "  --rm-when-done (optional)"
        echo -e "    Delete selected instances when scan is complete."
        echo -e "  --rm-logs (optional)"
        echo -e "    Delete remote and local logs when finished (default keeps all logs)"
        echo -e "  --shutdown-when-done (optional)"
        echo -e "    Shutdown selected instances when scan is complete."
        echo -e "  --debug (optional)"
        echo -e "    Enable debug mode (VERY VERBOSE!)"
        echo -e "  --quiet"
        echo -e "    Enable quiet mode"
        echo -e "  --cache"
        echo -e "    Do not regenerate SSH config"
        echo -e "  --help (optional)"
        echo -e "    Display this help menu"
        echo -e "  <additional args>"
        echo -e "    If you want additional arguments supplied to your command, simply append them to the command!"
}

###########################################################################################################
#  When CONTROL+C is pressed during a scan, perform exit housekeeping. Allow us to download and merge the available results after canceling
#
clean_up() { 

    kill -0 $remotetailPID 2>  /dev/null && kill -9 $remotetailPID  &> /dev/null
    kill -0 $tailPID 2>  /dev/null && kill -9 $tailPID  &> /dev/null
    kill -0 $downloaderPID 2>  /dev/null && kill -9 $downloaderPID  &> /dev/null
    echo -e "${Green}CTRL+C Interrupt, cleaning up and downloading output..${Color_Off}."
    $interlace_cmd_nobar -c "$ssh_command _target_ '[ -f $scan_dir/_target_ ] && echo _target_ scan finished || echo _target_ scan was still running but downloading partial results'"
    if [[ "$command" =~ "_target_" ]]; then
     $interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/output/ $tmp/output/ --cache -F=$sshconfig >/dev/null 2>&1"
    else
     $interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/output $tmp/output/_target_.$ext --cache -F=$sshconfig >/dev/null 2>&1"
    fi
    merge_output
    echo -e "${Blue}Killing remote processes in a backgroud job${Color_Off}"
    $interlace_cmd_nobar -c "$ssh_command _target_ 'tmux kill-session -t $uid'"  >/dev/null 2>&1
    $interlace_cmd_nobar -c "$ssh_exit_command _target_ " >/dev/null 2>&1
    mv "$AXIOM_PATH/tmp/$uid/" "$AXIOM_PATH/logs/"
    if [[ "$keeplogs" != "true" ]]; then
     delete_logs
    fi 
    end=$(date +%s)
    runtime=$((end-begin))
    time=$(formatSeconds $runtime)
    echo -e "${Blue}Appending axiom-scan runtime statistics to${Color_Off}${BGreen} : $AXIOM_PATH/stats.log${Color_Off}"
    echo "{\"scan\":{\"$module\":{\"id\":\"$uid\",\"extra_args\":\"$args\",\"instances\":\"$total_instances\",\"targets\":\"$lines\",\"results\":\"$output_lines\",\"runtime\":\"$time\",\"date\":\"$starttime\",\"command\":\"$command\",\"threads\":\"$threads\",\"local_logs\":\"$AXIOM_PATH/logs/$uid\",\"remote_logs\":\"/home/op/scan/$uid\",\"output\":\"$(realpath $outfile)\",\"status\":\"canceled\"}}}" | tee -a $AXIOM_PATH/stats.log  >> /dev/null 2>&1
    echo -e "${BGreen}module ${Color_Off}[${Blue} $module ${Color_Off}]${BGreen} | ${BGreen}args ${Color_Off}[${Blue} $args ${Color_Off}] ${BGreen}| ${BGreen}instances ${Color_Off}[${Blue} $total_instances ${Color_Off}]${BGreen} | ${BGreen}targets ${Color_Off}[${Blue} $lines targets ${Color_Off}]${BGreen} | ${BGreen}results ${Color_Off}[${Blue} $output_lines results ${Color_Off}]${BGreen} | ${BGreen}id ${Color_Off}[${Blue} "$uid" ${Color_Off}]${BGreen} |"
    echo -e "${BGreen}runtime ${Color_Off}[${Blue} $time ${Color_Off}]${BGreen} | ${BGreen}date ${Color_Off}[${Blue} $starttime ${Color_Off}]${BGreen} | ${BGreen}id ${Color_Off}[${Blue} "$uid" ${Color_Off}]${BGreen} | ${BGreen}threads ${Color_Off}[${Blue} "$threads" ${Color_Off}] ${BGreen}|"
    echo -e "${BGreen}log ${Color_Off}[${Blue} "$AXIOM_PATH/logs/$uid" ${Color_Off}]${BGreen} | ${BGreen}output ${Color_Off}[${Blue} $(realpath $outfile) ${Color_Off}]${BGreen} | ${BGreen}remote ${Color_Off}[${Blue} "/home/op/scan/$uid" ${Color_Off}] ${BGreen}"
    rm -r $socket_tmp >/dev/null 2>&1
    stty sane
    tput init
    exit $1
}

###########################################################################################################
#  axiom can take up a lot of space with logs. When --rm-logs option is present, after the scan is finished or canceled, axiom-exec will delete the remote logs.
#  To avoid undesirable scan results after merging, we keep the original un-merged scan result as well as the final merged copy. Everything else pertaining to the scan deleted.
#
delete_logs() {
 echo -e "${Blue}Deleting remote logs in a backgroud job${Color_Off}"
 axiom-exec "sudo rm -r /home/op/scan/${uid}/" --fleet "$AXIOM_PATH/logs/$uid/selected.conf"  >/dev/null 2>&1 &
  if [ -d "$AXIOM_PATH/logs/$uid/" ] 
   then
   echo -e "${Blue}Deleting local logs, except for $AXIOM_PATH/logs/$uid/output/ ${Color_Off}"
   start=$(pwd)
   cd "$AXIOM_PATH/logs/$uid/" || exit 
   ls | grep -v output | xargs rm -r >/dev/null 2>&1
   cd "$start"
  else
    echo "Error: local log folder does not exist."
fi
}

###########################################################################################################
#  Providing wordlists in modules can be done with _wordlist_, usually something like -w _wordlist_ is provided in the module. Think of this like a placeholder for wordlists
#  that can be easily switched out in-line or from the module. Look at the nuclei module for an example of _wordlist_ being used in a "simple module" https://github.com/pry0cc/axiom/blob/master/modules/nuclei.json.
#  Example command: axiom-scan mytargets.txt -m nuclei -w /home/op/my-nuclei-templates-on-remote-server/ -o myresults.txt. Although Nuclei doesnt have a -w
#  in this case, we are treating Nuclei's -templates(-t) argument as a wordlist (-w). In essence we are overwriting the wordlist argument for all modules, in an attempt to normalize the '-w' for all modules.
#
apply_wordlist() {
    command="$1"
    wordlist="$2"
    wordlist_escaped="$(echo "$wordlist" | sed 's/\//\\\//g')"
    echo "$command" | sed "s/_wordlist_/$wordlist_escaped/g"
}

###########################################################################################################
#  Parse the extra arguments passed from the command line and add them to the final command
#  TODO: use gee's prefix and suffix features instead
#
add_extra_args() {
    command="$1"
    new_command=""
    args="$2"
    args_set="false"

    counter=0
    pieces="$(echo "$command" | grep -o "|" | wc -l | awk '{ print $1 }')"

    OLDIFS=$IFS
    IFS="|" 
    for piece in $command
    do
        if [[ "$piece" != "" ]] && [[ ! "$piece" =~ "cat" ]] && [[ ! "$piece" =~ "tee" ]] && [[ "$args_set" != "true" ]]; then
            new_command="$new_command $piece $args"
            args_set=""true
        else
            new_command="$new_command $piece"
        fi

        if [[ "$counter" -lt "$pieces" ]]; then
            new_command="$new_command | "
            counter=$((counter+1))
        fi
    done

    IFS=$OLDIFS
    echo $new_command
}

###########################################################################################################
#  divide the the target list by how many instances are selected (axiom-select). Equally distribute the total target list across the fleet.
#  If gee is present, use it over bash. gee is an incredibly useful tool for distribution https://github.com/hahwul/gee <3 hahwul
#
split_file() {
file="$1"
divisor="$2"
tmp="$3"

# if gee is NOT-installed, use bash
if ! [ -x "$(command -v gee)" ]; then
    lines="$(wc -l "$file" | awk '{ print $1 }')"
    lines_per_file=$(expr $lines / $divisor)
    [[ $(expr $lines % $divisor) != 0 ]] && lines_per_file=$(expr $lines_per_file + 1)
 
# randomize the target list. To disable randomization, use the --dont-shuffle option 
if [[ "$shuffle" != "false" ]]; then
    shuf "$file" > "$tmp/split/targets"
else
cp "$file" "$tmp/split/targets"
fi
cd "$tmp/split" && split -l $lines_per_file targets && rm targets && cd "$start"

# Rename "xaa" etc  to 1 2 3 4 5
i=1
for f in $(find "$tmp/split/" -type f | tr '/' ' ' | awk '{ print $NF }')
do
        instance="$(echo $instances | awk "{ print \$$i }")"
        i=$((i+1))

        mv "$tmp/split/$f" "$tmp/input/$instance"
    done
    total=$i

else

# if gee is installed make sure its up to date, use gee to split the file. 
GO111MODULE=on go get -v github.com/hahwul/gee >/dev/null 2>&1
escapedtmp=$(echo $tmp | sed 's;/;\\/;g')
# randomize the target list. To disable randomization, use the --dont-shuffle option.
if [[ "$shuffle" != "false" ]]; then
    shuf "$file" | gee -distribute $(cat $tmp/selected.conf | sed -e 's/^/'$escapedtmp'\/input\//' | tr '\n' ' ') &>/dev/null 
else
    cat "$file" | gee -distribute $(cat $tmp/selected.conf | sed -e 's/^/'$escapedtmp'\/input\//' | tr '\n' ' ') &>/dev/null 
fi
    total=$(ls $tmp/input | wc -l)
fi
}

###########################################################################################################
#  Merge the output in a certain way specified in the module or if the user specified -oX -oG or -oD it will overwrite the default (-o).
#  If only supplying -o as an output argument via the command line, the output format will default to the first extension mentioned in the module.
#
merge_output() {
    if [[ "$anew" != "true" ]];  then
     if [ -f "$outfile" ] ; then
      rm -rf "$outfile"
     fi
    fi
    if [[ "$ext" == "txt" ]]; then
        echo "Mode set to txt.. Sorting unique."
        find $tmp/output/ -type f -exec cat {} \; | sort -u > $tmp/merge
        output_lines=$(wc -l $tmp/merge | tr -s ' ' | cut -d ' ' -f 1)
        if [[ "$anew" == "true" ]]; then
            cat "$tmp/merge" | anew "$outfile"
        else
            mv "$tmp/merge" "$outfile"
        fi
    elif [[ "$ext" == "xml" ]]; then
        echo "Mode set to XML.. Merging Nmap XML output..."
        "$AXIOM_PATH/interact/merge-xml.py" -d "$tmp/output" -o "$tmp/merge.xml" >> /dev/null
        mv "$tmp/merge.xml" "$outfile"
        mv "$tmp/merge.xml.html" "$outfile.html"
    elif [[ "$ext" == "csv" ]]; then
        echo "Mode set to CSV, merging..."
        header="$(find $tmp/output/ -type f -exec head -n 1 {} \; | sort -u )"
        echo "$header" > "$outfile"
        find $tmp/output/ -type f -exec cat {} \; | grep -v "$header" | sort -u -V >> "$outfile"
        output_lines=$(wc -l $outfile | tr -s ' ' | cut -d ' ' -f 1)
    elif [[ "$ext" == "" ]] || [[ "$ext" == "dir" ]];  then
            echo "Mode set to directory... Merging directories..."
            mkdir $tmp/merge
            find $tmp/output -type f -print0 | xargs -0 -I{} cp --backup=t {} $tmp/merge
            output_lines=$(ls $tmp/merge | wc -l)
          if [ -f "$outfile" ] ; then
             rm -rf "$outfile"
            fi
            mv $tmp/merge "$outfile"
        if [[ "$module" == "gowitness" ]]; then
            echo "Downloading gowitness databases..."
            mkdir -p "$tmp/dbs/"
            $interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/gowitness.sqlite3 $tmp/dbs/_target_.sqlite3 --cache -F=$sshconfig>> /dev/null"
            echo "Merging databases..."
            gowitness merge --input-path $tmp/ -o gowitness.sqlite3
            echo -e "${Green}RUN: '${Blue}gowitness -D gowitness.sqlite3 -P screenshots report serve${Color_Off}' for reporting"
        fi
           if [[ "$module" == "naabu-nmap" ]]; then
            echo "Merging naabu and nmap output"
            find . -name "*.txt" | xargs cat | sort -u > $outfile/final_naabu.txt
            echo "Merging Nmap XML output..."
            "$AXIOM_PATH/interact/merge-xml.py" -d "$outfile" -o "$outfile/final_nmap.xml" >> /dev/null
           if [ -f "$outfile" ] ; then
            rm -rf $outfile/naabu*
            rm -rf $outfile/nmap*
           fi
            echo -e "${Green}Done: '${Blue}Merging both naabu ouput and nmap${Color_Off}'"
        fi
    fi
}

###########################################################################################################
#  Declare defaut variables
#
starttime=$(date)
wordlist=""
module=""
ext="default"
default_wordlist="/home/op/nuclei-templates/"
local_wordlist=""
user_specified_wordlist=""
cache="false"
fleet=""
threads=""
interactive=""
uid="$module+$(date +%s)"
outfile="$start/scan+$(date +%s)"
sshconfig="$AXIOM_PATH/.sshconfig"
rm_when_done="false"
spinup=0
args=""
pass=()
keeplogs="true"
shuffle="true"
split="true"
distribute_wordlist="false"
quiet="false"

###########################################################################################################
#  Parse command line arguments 
#
i=0
for arg in "$@"
do
    i=$((i+1))
    if [[  ! " ${pass[@]} " =~ " ${i} " ]]; then
        set=false
        if [[ "$i" == 1 ]]; then
            input="$1"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "-m" ]]; then
            n=$((i+1))
            module=$(echo ${!n})

            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--anew" ]]; then
            n=$((i+1))
            anew="true"
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "-F" ]]; then
            n=$((i+1))
            sshconfig=$(echo ${!n})
            cache="true"
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--cache" ]]; then
            cache="true"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--quiet" ]]; then
            quiet="true"
            set=true
            pass+=($i)
        fi        
        if [[ "$arg" == "--rm-when-done" ]]; then
            rm_when_done="true"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--shutdown-when-done" ]] || [[ "$arg" == "--poweroff-when-done" ]] || [[ "$arg" == "--shutdown" ]]; then
            shutdown_when_done="true"
            set=true
            pass+=($i)
        fi

        if [[ "$arg" == "--list" ]]; then
            list_modules
            exit
        fi
        if [[ "$arg" == "-o" ]]; then
            n=$((i+1))
            outfile=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--threads" ]]; then
            n=$((i+1))
            user_specified_threads=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "-w" ]]; then
            n=$((i+1))
            user_specified_wordlist=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "-wL" ]]; then
            n=$((i+1))
            local_wordlist=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--distribute-wordlist" ]] || [[ "$arg" == "-wD" ]]; then
            distribute_wordlist="true"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "-oD" ]] || [[ "$arg" == "-oA" ]]; then
            n=$((i+1))
            ext="dir"
            outfile=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi 
        if [[ "$arg" == "--spinup" ]]; then
            n=$((i+1))
            spinup=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "-oG" ]]; then
            n=$((i+1))
            ext="txt"
            outfile=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--fleet" ]] || [[ "$arg" == "-f" ]]; then
            n=$((i+1))
            fleet=$(echo ${!n})
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "-oX" ]]; then
            n=$((i+1))
            ext="xml"
            outfile=$(echo ${!n})
            echo "Setting outfile to: '$outfile'"
            set=true
            pass+=($i)
            pass+=($n)
        fi
        if [[ "$arg" == "--help" ]] || [[ "$arg" == "-h" ]]; then
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--debug" ]]; then
            debug="true"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--rm-logs" ]]; then
            keeplogs="false"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--dont-shuffle" ]]; then
            shuffle="false"
            set=true
            pass+=($i)
        fi
        if [[ "$arg" == "--dont-split" ]]; then
            split="false"
            set=true
            pass+=($i)
        fi
        if  [[ "$set" != "true" ]]; then
            args="$args $arg"
        fi

    fi
done

###########################################################################################################
#  Display axiom banner and authors 
#
echo -e -n "${BWhite}"
echo "ICAgICAgICAgICAgICBfCiAgX19fXyBfXyAgX18oXylfX18gIF9fX18gX19fICAgICAgICBfX19fX19fX19fX19fXyBfX19fXwogLyBfXyBgLyB8L18vIC8gX18gXC8gX18gYF9fIFxfX19fX18vIF9fXy8gX19fLyBfXyBgLyBfXyBcCi8gL18vIC8+ICA8LyAvIC9fLyAvIC8gLyAvIC8gL19fX19fKF9fICApIC9fXy8gL18vIC8gLyAvIC8KXF9fLF8vXy98Xy9fL1xfX19fL18vIC9fLyAvXy8gICAgIC9fX19fL1xfX18vXF9fLF8vXy8gL18vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAcHJ5MGNjCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYgQDB4dGF2aWFuCg==" | base64 -d
echo -e  "${Color_Off}"

###########################################################################################################
# Display Help Menu
#
if [[ "$*" == "--help" ]] || [[ "$*" == "-h" ]] || [[ "$*" == "" ]]; then
 help
 exit
fi

###########################################################################################################
#  Exit if the first command line argument doesnt not contain a target list
#
if [[ ! -f $input ]]; then
        echo -e "${BRed}Input file does not exist, please specify one as the first argument... ${Color_Off}"
        help
        exit 1
fi

###########################################################################################################
#  Check if -m is in the command, if not, exit
#
if [[ "$*" != *-m* ]]
then
  echo -e "\033[0;31m No module for axiom-scan defined. Pass one with -m."
        help
        exit 1
fi

###########################################################################################################
#  Exit if module doesnt exist
#
if [ ! -f $AXIOM_PATH/modules/$module.json ]; then
 echo -e "\033[0;31mERROR: Axiom module not found."
 echo -e "Ensure module exists in $AXIOM_PATH/modules/$module.json"
 echo -e "To print all available modules run axiom-scan --list"
 exit 1
fi

###########################################################################################################
#  Create temporary directories and set tmp path to be used for logs
#
uid="$module+$(date +%s)"
tmp="$AXIOM_PATH/tmp/$uid"
completed="$AXIOM_PATH/tmp/$uid/status/completed/"
inprogress="$AXIOM_PATH/tmp/$uid/status/inprogress/"
mkdir -p "$tmp/input"
mkdir -p "$tmp/split"
mkdir -p "$tmp/output"
mkdir -p "$tmp/logs"
mkdir -p "$completed"
mkdir -p "$inprogress"

###########################################################################################################
#  Spinup Flag
#
if [[ "$spinup" -gt 0 ]]; then
    echo -e "${Blue}Spinning up fleet with $spinup instances..${Color_Off}"
    "$AXIOM_PATH/interact/axiom-fleet" -i "$spinup"
    echo -e "${Green}Waiting 60 seconds before scan...${Color_Off}"
    sleep 60
fi

###########################################################################################################
#  SSH Cache Flag
#
if [[ "$cache" == "false" ]]; then
    generate_sshconfig
fi

###########################################################################################################
#  cp the selected.conf to different file names ( one for Interlace, one for selected.conf)
#  Make a copy of the current SSH config and use it for axiom-scan
#
cat "$AXIOM_PATH/selected.conf" >> "$tmp/hosts"
cp "$AXIOM_PATH/selected.conf" "$tmp/selected.conf"
cp "$sshconfig" "$tmp/sshconfig" 
sshconfig="$tmp/sshconfig"

###########################################################################################################
#  Create temporary SSH sockets to use with axiom-scan. An advantage of SSH multiplexing is that the overhead
#  of creating new TCP connections and negotiating the secure connection is eliminated. This allow us to do
#  subsequent SSH exec operations ( like downloading results etc ) with no additional overhead. 
#
mkdir -p "$AXIOM_PATH/tmp/$uid/sockets"
socket_tmp=$(echo "$AXIOM_PATH/tmp/$uid/sockets")
cat <<EOT >> $(echo $sshconfig)
Host * 
    ControlMaster auto 
    ControlPath $socket_tmp/%r@%h-%p  
    ControlPersist 600
EOT

###########################################################################################################
#  Variables to display about the scan
#
input_file="$1"
total_instances="$(wc -l "$tmp/hosts" | awk '{ print $1 }')"
lines="$(wc -l "$input_file" | awk '{ print $1 }')"

###########################################################################################################
#  Check total instances does not equal zero
#
if [[ "$total_instances" -eq "0" ]]; then
   echo "error with number of instances, exiting";
   exit;
fi

###########################################################################################################
#  Check is input file is empty
#
if [[ "$lines" -eq "0" ]]; then
   echo "error input file is empty, exiting";
   exit;
fi

###########################################################################################################
#  Debug Flag
#
if [[ "$debug" == "true" ]]; then
    set -xv
    silent=""
fi

###########################################################################################################
#  Normalize extension for ffuf and gowitness
#  This might not be requried anymore
#
if [[ "$module" =~ "ffuf" ]]; then
    ext="csv"
fi

if [[ "$module" == "gowitness" ]]; then
    ext=""
fi

###########################################################################################################
#  Prevents Interlace hangups from hijacking your terminal  
#
stty -echoctl
trap clean_up SIGINT SIGTERM

###########################################################################################################
#  Fleet flag
#
if [[ "$fleet" == "" ]]; then
    instances=$(cat "$tmp/hosts")
else
    instances=$(query_instances_cache "$fleet*")
    echo "$instances" | tr ' ' '\n' > "$tmp/hosts"
    total_instances="$(wc -l "$tmp/hosts" | awk '{ print $1 }')"
fi

###########################################################################################################
#  Destination directory on the instances and the command used to SSH to them
#  Add default SSH commands
#  Add default interlace command
#
scan_dir="/home/op/scan/$uid"
ssh_command="ssh -F $sshconfig -o StrictHostKeyChecking=no"
ssh_exit_command="ssh -F $sshconfig -O exit -o StrictHostKeyChecking=no"

interlace_cmd="$(which interlace) --silent -tL $tmp/hosts -threads $total_instances"
interlace_cmd_nobar="$(which interlace) --no-bar --silent -tL $tmp/hosts -threads $total_instances"

###########################################################################################################
#  Figure out what wordlist to use - default, the module default or the user specified wordlist
#
module_default_wordlist="$(parse_module "$module" | jq -r '.wordlist?')"

if [[ "$module_default_wordlist" != "" ]]; then
    default_wordlist="$module_default_wordlist"
fi

if [[ "$user_specified_wordlist" != "" ]]; then
    wordlist="$user_specified_wordlist"
else
    wordlist="$default_wordlist"
fi

destination_wordlist=""
if [[ "$local_wordlist" != "" ]]; then
    if [[ -f "$local_wordlist" ]]; then
        local_wordlist_filename="$(echo "$local_wordlist" | tr '/' ' ' | awk '{ print $NF }')"
        total=$(wc -l "$tmp/selected.conf" | awk '{ print $1 }')
        destination_wordlist="/home/op/lists/$local_wordlist_filename"
        wordlist="$destination_wordlist"
    else
        echo -e "${Red}Error: file not found '$local_wordlist'...${Color_Off}"
        exit 1
    fi
fi

###########################################################################################################
#  If -wL (wordlist-local) is present in the command line, upload a user provider wordlist to use.
#  If -wD or --distribute-wordlist is present in the command line, split and upload the user provided wordlist.
#
if [[ -f "$local_wordlist" ]]; then
if [[ "$distribute_wordlist" == "false" ]]; then
    echo -e "${Green}Uploading local wordlist: $local_wordlist_filename to $destination_wordlist...${Color_Off}"
    interlace --no-bar --silent -threads $total -tL "$tmp/selected.conf" -c "$AXIOM_PATH/interact/axiom-scp $local_wordlist  _target_:$destination_wordlist --cache -F=$sshconfig >> /dev/null"
    echo -e "${Green}Wordlist uploaded successfully!${Color_Off}"
else
    echo -e "${Green}Splitting and uploading local wordlist: $local_wordlist_filename to $destination_wordlist...${Color_Off}"
    mkdir -p $tmp/distribute_wordlist/split
    mkdir -p $tmp/distribute_wordlist/input
    cp "$tmp/selected.conf" "$tmp/distribute_wordlist/selected.conf"
    # hack to stop overwriting $lines and $tmp
    lines1=$lines && tmp1=$tmp
    split_file "$local_wordlist" "$total_instances" $tmp/distribute_wordlist
    # hack to stop overwriting $lines and $tmp
    lines=$lines1 && tmp=$tmp1
    $interlace_cmd_nobar -c "$AXIOM_PATH/interact/axiom-scp $tmp/distribute_wordlist/input/_target_ _target_:$destination_wordlist --cache -F=$sshconfig >/dev/null 2>&1" | grep -v "Gen"
    echo -e "${Green}Distributed wordlist successfully!${Color_Off}"

fi
fi

###########################################################################################################
#  Parse the default extention from the module
#
if [[ "$ext" == "default" ]]; then
    ext="$(parse_module "$module" | jq -r '.ext')"
fi

###########################################################################################################
#  If a wordlist is specified add it to the command
#  Combine commands in the module with the arguments passed from the command line into final command
#
command="$(parse_module "$module" "$ext" | jq -r '.command')"
command="$(apply_wordlist "$command" "$wordlist")"
command="$(add_extra_args "$command" "$args")"

###########################################################################################################
#  Parse default or user specified threads in one-shot modules
#
default_threads="$(parse_module "$module" | jq -r '.threads?')"
if [[ "$default_threads" != "" ]]; then
    threads="$default_threads"
fi

if [[ "$user_specified_threads" != "" ]]; then
    threads="$user_specified_threads"
fi

###########################################################################################################
#  If the final command contains the sting _target_, display stats about one-shot modules
#
if [[ "$command" =~ "_target_" ]]; then
    thread_str="${BWhite}Threads:${Color_Off} [ ${Red}$threads${Color_Off} ] | "
fi

###########################################################################################################
#  Display some stats prior to scanning
#
echo -e "${BWhite}Module:${Color_Off} [ ${Blue}$module${Color_Off} ] | ${BWhite}Extra Args:${Color_Off} [${Blue}$args${Color_Off} ] | ${BWhite}Input:${Color_Off} [ ${Blue}$lines targets${Color_Off} ] | ${BWhite}Scan uid:${Color_Off} [ ${Blue}$uid${Color_Off} ]"
echo -e "${BWhite}Instances:${Color_Off} $total_instances [${Blue} $(echo $instances | tr '\n' ' ')${Color_Off}]"
echo -e "${BWhite}Command:${Color_Off} [ ${Blue}$command${Color_Off} ] | $thread_str${BWhite}Ext${Color_Off}: [${Blue}$ext${Color_Off}]"

###########################################################################################################
#  If a one-shot module is used:
#  Prep all the axiom instances by making a unique scan directory 
#  Store Interlace command in a file and upload it to remote instances with axiom-scp
#
echo -n -e "${Blue}Building file structure...${Color_Off}"
if [[ "$command" =~ "_target_" ]] || [[ "$ext" ==  "" ]] || [[ "$ext" == "dir" ]]; then
    $interlace_cmd_nobar -c "$ssh_command _target_ 'mkdir -p $scan_dir/output'" >/dev/null 2>&1
    echo "$command" > "$tmp/command"
    $interlace_cmd_nobar -c "axiom-scp $tmp/command _target_:$scan_dir/command --cache -F=$sshconfig >/dev/null 2>&1" >/dev/null 2>&1
else

###########################################################################################################
#  If a Simple Module is used:
#  Prep all the axiom instances by making a unique scan directory with SSH exec
#  Store Bash command in a file and upload it to remote instances with axiom-scp
#
    $interlace_cmd_nobar -c "$ssh_command _target_ 'mkdir -p $scan_dir'" >/dev/null 2>&1
    echo "$command" > "$tmp/command"
    $interlace_cmd_nobar -c "axiom-scp $tmp/command _target_:$scan_dir/command --cache -F=$sshconfig >/dev/null 2>&1" >/dev/null 2>&1

fi
echo -n -e "[ ${Green}OK${Color_Off} ]\n"

###########################################################################################################
#  split target list or copy target list
# 
if [[ "$split" == "true" ]]; then
    split_file "$input_file" "$total_instances" "$tmp"
    else
    for i in $(echo $instances); do cp "$input_file" $tmp/input/$i ; done 
fi

###########################################################################################################
#  use axiom-scp to upload each input file to a remote instance
#
echo -e "${Blue}Uploading input files...${Color_Off}"
$interlace_cmd_nobar -c "$AXIOM_PATH/interact/axiom-scp $tmp/input/_target_ _target_:$scan_dir/input --cache -F=$sshconfig >/dev/null 2>&1; touch $tmp/logs/_target_" | grep -v "Gen" 

###########################################################################################################
#  Dont tail if quiet is true
# 
if [[ "$quiet" == "false" ]]; then
    tail -q -f $tmp/logs/* &
    tailPID=$!
fi

###########################################################################################################
#  This function is spanwed in the background and periodically probes all instances to see if their part of the scan has completed.
#  When the remote scan process has finished, it creates a file named $HOSTNAME in the remote scan working directory. During the
#  scan if axiom see's the $HOSTNAME file, download the scan results
#
function downloader () {
while true; do
sleep 30
$interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/_target_ $tmp/status/inprogress/_target_ --cache -F=$sshconfig >/dev/null 2>&1" 
ls $tmp/status/inprogress/ | anew -q $tmp/status/completed/hosts 
cat $tmp/status/completed/hosts | sort -u | wc -l | tee $tmp/status/downloader_instances  >/dev/null 2>&1
cat $tmp/status/completed/hosts | sort -u | tee $tmp/status/downloader_hosts  >/dev/null 2>&1
if [[ "$(cat $tmp/status/downloader_instances)" -eq "0"  ]]; then
 sleep 10
 downloader
fi
downloader_cmd="$(which interlace) --no-bar --silent -tL $tmp/status/downloader_hosts -threads $(cat $tmp/status/downloader_instances)" 
if [[ "$command" =~ "_target_" ]]; then
$downloader_cmd -c "axiom-scp _target_:$scan_dir/output/ $tmp/output/ --cache -F=$sshconfig >/dev/null 2>&1" 
else
$downloader_cmd -c "axiom-scp _target_:$scan_dir/output $tmp/output/_target_.$ext --cache -F=$sshconfig >/dev/null 2>&1"
fi

mv $tmp/status/completed/hosts $tmp/status/completed/hosts.tmp
cat $tmp/status/completed/hosts.tmp | sort -u >> $tmp/status/completed/hosts
 if cmp -s $tmp/status/completed/hosts $tmp/hosts ; then
  kill -9 $(cat $tmp/status/remotetailPID)  >> /dev/null 2>&1
  wait $(cat $tmp/status/remotetailPID)  >> /dev/null 2>&1 
 break >> /dev/null 2>&1
 else
  downloader
 fi
done
}

###########################################################################################################
#  Install anew if not already installed
#
if ! [ -x "$(command -v anew)" ]; then
go get -u github.com/tomnomnom/anew >> /dev/null 2>&1
fi

###########################################################################################################
#  Start the One Shot Module scan by SSH-ing into each instance and running the Interlace command on every remote instance
#
if [[ "$command" =~ "_target_" ]]; then
 echo -e "${BRed}[*]${Red} ENABLING ONESHOT MODE! STARTING $(($total_instances * $threads)) TOTAL THREADS. Using $threads threads per instance with $total_instances instances...${Color_Off}"
 touch $tmp/status/completed/hosts
 touch $tmp/status/completed/status
 sleep 3
 downloader &
 downloaderPID=$!
 $interlace_cmd_nobar -c "$ssh_command _target_ 'cd $scan_dir && touch stderr.log stdout.log && tail -f stderr.log & tail -f stdout.log' >> $tmp/logs/_target_ 2>&1 " &
 remotetailPID=$!
 echo $remotetailPID > $tmp/status/remotetailPID
 $interlace_cmd_nobar -c "$ssh_command _target_ 'tmux new -d -s $uid && tmux send-keys -t $uid \"cd $scan_dir; interlace --silent -threads $threads -tL input -cL command -o output > >(tee -a stdout.log) 2> >(tee -a stderr.log >&2) ; touch _target_\" ENTER ' \"&& tmux send-keys -t $uid exit ENTER\""
 wait $remotetailPID  >> /dev/null 2>&1
 $interlace_cmd_nobar -c "$ssh_command _target_ '[ -f $scan_dir/_target_ ] && echo _target_ scan finished || echo _target_ scan was still running but downloading partial results'"
 $interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/output/ $tmp/output/ --cache -F=$sshconfig >/dev/null 2>&1"

###########################################################################################################
#  Start the Simple Module scan SSH-ing into each instance and running the Bash command on every remote instance
#
else
 touch $tmp/status/completed/hosts
 touch $tmp/status/completed/status
 sleep 3
 downloader &
 downloaderPID=$!
 $interlace_cmd_nobar -c "$ssh_command _target_ 'cd $scan_dir && touch stderr.log stdout.log && tail -f stderr.log & tail -f stdout.log' >> $tmp/logs/_target_ 2>&1 " &
 remotetailPID=$!
 echo $remotetailPID > $tmp/status/remotetailPID
 $interlace_cmd_nobar -c "$ssh_command _target_ 'tmux new -d -s $uid && tmux send-keys -t $uid \"cd $scan_dir; bash -i command  > >(tee -a stdout.log) 2> >(tee -a stderr.log >&2) ; touch _target_\" ENTER ' \"&& tmux send-keys -t $uid exit ENTER\""
 wait $remotetailPID  >> /dev/null 2>&1
 $interlace_cmd_nobar -c "$ssh_command _target_ '[ -f $scan_dir/_target_ ] && echo _target_ scan finished || echo _target_ scan was still running but downloading partial results'"
 $interlace_cmd_nobar -c "axiom-scp _target_:$scan_dir/output $tmp/output/_target_.$ext --cache -F=$sshconfig >/dev/null 2>&1"
fi

###########################################################################################################
#  After downloading all the results merge the output 
#
merge_output

###########################################################################################################
#  shutdown axiom instances after scan completes if --shutdown-when-done is in the command
#
if [[ "$shutdown_when_done" == "true" ]]; then
    for instance in $(cat "$tmp/selected.conf");
    do
        "$AXIOM_PATH/interact/axiom-power" off "$instance" 
        sleep 0.4
    done
fi

###########################################################################################################
#  Deprovision axiom instances after scan completes if --rm-when-done is in the command
#
if [[ "$rm_when_done" == "true" ]]; then
    for instance in $(cat "$tmp/selected.conf");
    do
        "$AXIOM_PATH/interact/axiom-rm" "$instance" -f
        sleep 0.4
    done
fi

end=$(date +%s)
runtime=$((end-begin))
time=$(formatSeconds $runtime)

###########################################################################################################
#  kill tmux sessions with any orphaned proceses
#
$interlace_cmd_nobar -c "$ssh_command _target_ 'tmux kill-session -t $uid'"  >/dev/null 2>&1
$interlace_cmd_nobar -c "$ssh_exit_command _target_ " >/dev/null 2>&1

###########################################################################################################
#  Move downloaded raw results to log file
#
mv "$AXIOM_PATH/tmp/$uid/" "$AXIOM_PATH/logs/"

###########################################################################################################
#  If delete logs is set to true, execute delete_logs function.
#
if [[ "$keeplogs" == "false" ]]; then
delete_logs
fi

###########################################################################################################
#  Display exit stats about the scan such as log directory 
#  Normalize terminal
#
echo -e "${Blue}Appending axiom-scan runtime statistics to${Color_Off}${BGreen} : $AXIOM_PATH/stats.log${Color_Off}"
echo "{\"scan\":{\"$module\":{\"id\":\"$uid\",\"extra_args\":\"$args\",\"instances\":\"$total_instances\",\"targets\":\"$lines\",\"results\":\"$output_lines\",\"runtime\":\"$time\",\"date\":\"$starttime\",\"command\":\"$command\",\"threads\":\"$threads\",\"local_logs\":\"$AXIOM_PATH/logs/$uid\",\"remote_logs\":\"/home/op/scan/$uid\",\"output\":\"$(realpath $outfile)\",\"status\":\"completed\"}}}" | tee -a $AXIOM_PATH/stats.log  >> /dev/null 2>&1
echo -e "${BGreen}module ${Color_Off}[${Blue} $module ${Color_Off}]${BGreen} | ${BGreen}args ${Color_Off}[${Blue} $args ${Color_Off}] ${BGreen}| ${BGreen}instances ${Color_Off}[${Blue} $total_instances ${Color_Off}]${BGreen} | ${BGreen}targets ${Color_Off}[${Blue} $lines targets ${Color_Off}]${BGreen} | ${BGreen}results ${Color_Off}[${Blue} $output_lines results ${Color_Off}]${BGreen} | ${BGreen}id ${Color_Off}[${Blue} "$uid" ${Color_Off}]${BGreen} |"
echo -e "${BGreen}runtime ${Color_Off}[${Blue} $time ${Color_Off}]${BGreen} | ${BGreen}date ${Color_Off}[${Blue} $starttime ${Color_Off}]${BGreen} | ${BGreen}id ${Color_Off}[${Blue} "$uid" ${Color_Off}]${BGreen} | ${BGreen}threads ${Color_Off}[${Blue} "$threads" ${Color_Off}] ${BGreen}|"
echo -e "${BGreen}log ${Color_Off}[${Blue} "$AXIOM_PATH/logs/$uid" ${Color_Off}]${BGreen} | ${BGreen}output ${Color_Off}[${Blue} $(realpath $outfile) ${Color_Off}]${BGreen} | ${BGreen}remote ${Color_Off}[${Blue} "/home/op/scan/$uid" ${Color_Off}] ${BGreen}"
rm -r $socket_tmp >/dev/null 2>&1

kill -0 $remotetailPID 2>  /dev/null && kill -9 $remotetailPID  &> /dev/null
kill -0 $tailPID 2>  /dev/null && kill -9 $tailPID  &> /dev/null
kill -0 $downloaderPID 2>  /dev/null && kill -9 $downloaderPID  &> /dev/null
wait $tailPID 2>/dev/null
wait $downloaderPID 2>/dev/null
stty sane
tput init
